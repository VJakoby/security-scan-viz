import { useState, useCallback, useEffect } from 'react';
import { Vulnerability, VulnerabilityData, ColumnMapping, SeverityCount, ProtocolCount, VisualizationOptions } from '@/types/vulnerability';

const STORAGE_KEY = 'vulnerability-data';

export const useVulnerabilityData = () => {
  const [vulnerabilities, setVulnerabilities] = useState<Vulnerability[]>([]);
  const [customerName, setCustomerName] = useState<string>('');
  const [visualizations, setVisualizations] = useState<VisualizationOptions>({
    id: 'none',
    title: 'none',
    asset: 'none',
    ipAddress: 'none',
    score: 'none'
  });

  // Load data from localStorage on mount
  useEffect(() => {
    const stored = localStorage.getItem(STORAGE_KEY);
    const storedCustomer = localStorage.getItem('customer-name');
    const storedVisualizations = localStorage.getItem('visualizations');
    if (stored) {
      try {
        const parsed = JSON.parse(stored);
        setVulnerabilities(parsed);
      } catch (error) {
        console.error('Error parsing stored data:', error);
      }
    }
    if (storedCustomer) {
      setCustomerName(storedCustomer);
    }
    if (storedVisualizations) {
      try {
        const parsed = JSON.parse(storedVisualizations);
        setVisualizations(parsed);
      } catch (error) {
        console.error('Error parsing stored visualizations:', error);
      }
    }
  }, []);

  const normalizeSeverity = useCallback((severity: string): Vulnerability['severity'] => {
    if (!severity) return 'Unknown';
    const s = severity.toString().toLowerCase();
    if (s.includes('crit')) return 'Critical';
    if (s.includes('high')) return 'High';
    if (s.includes('med')) return 'Medium';
    if (s.includes('low')) return 'Low';
    return 'Unknown';
  }, []);

  const mapData = useCallback((
    rawData: VulnerabilityData[],
    mapping: ColumnMapping
  ): Vulnerability[] => {
    const mapped = rawData.map((row, index) => ({
      id: mapping.id === '-' ? `vuln-${index + 1}` : (row[mapping.id]?.toString() || `vuln-${index + 1}`),
      title: mapping.title === '-' ? 'N/A' : (row[mapping.title]?.toString() || 'N/A'),
      asset: mapping.asset === '-' ? 'N/A' : (row[mapping.asset]?.toString() || 'N/A'),
      ipAddress: mapping.ipAddress === '-' ? 'N/A' : (row[mapping.ipAddress]?.toString() || 'N/A'),
      severity: normalizeSeverity(mapping.severity === '-' ? '' : row[mapping.severity]?.toString()),
      score: mapping.score === '-' ? 0 : parseFloat(row[mapping.score]?.toString() || '0') || 0,
      protocol: 'N/A',
    }));

    // Deduplicate by ID, keeping the highest score for each unique ID
    const deduplicatedMap = new Map<string, Vulnerability>();
    
    mapped.forEach(vuln => {
      const existingVuln = deduplicatedMap.get(vuln.id);
      if (!existingVuln || vuln.score > existingVuln.score) {
        deduplicatedMap.set(vuln.id, vuln);
      }
    });

    return Array.from(deduplicatedMap.values());
  }, [normalizeSeverity]);

  const saveData = useCallback((data: Vulnerability[], customer?: string, visualizationOptions?: VisualizationOptions) => {
    setVulnerabilities(data);
    if (customer) {
      setCustomerName(customer);
      localStorage.setItem('customer-name', customer);
    }
    if (visualizationOptions) {
      setVisualizations(visualizationOptions);
      localStorage.setItem('visualizations', JSON.stringify(visualizationOptions));
    }
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }, []);

  const clearData = useCallback(() => {
    setVulnerabilities([]);
    setCustomerName('');
    setVisualizations({
      id: 'none',
      title: 'none',
      asset: 'none',
      ipAddress: 'none',
      score: 'none'
    });
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem('customer-name');
    localStorage.removeItem('visualizations');
  }, []);

  const getSeverityCount = useCallback((): SeverityCount => {
    return vulnerabilities.reduce((acc, vuln) => {
      acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
      return acc;
    }, {
      Critical: 0,
      High: 0,
      Medium: 0,
      Low: 0,
      Unknown: 0
    });
  }, [vulnerabilities]);

  const getTopVulnerabilitiesBySeverity = useCallback((severity: Vulnerability['severity'], limit = 10) => {
    return vulnerabilities
      .filter(v => v.severity === severity)
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);
  }, [vulnerabilities]);


  return {
    vulnerabilities,
    customerName,
    visualizations,
    mapData,
    saveData,
    clearData,
    getSeverityCount,
    getTopVulnerabilitiesBySeverity
  };
};